<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2019%2F05%2F16%2Fshell%2F</url>
    <content type="text"><![CDATA[Shell基础1#!/bin/bash 代表指定某个解析器 运行某个shell脚本1. test.sh 接收外部参数12$1 $2 单个接收$@ $* 全部接收，用双引号包含区分，$@每个参数为1份，$*所有参数为一份 获取字符串长度1$&#123;#string_name&#125; 从指定位置开始截取12345678910格式 说明$&#123;string: start :length&#125; 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。$&#123;string: start&#125; 从 string 字符串的左边第 start 个字符开始截取，直到最后。$&#123;string: 0-start :length&#125; 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。$&#123;string: 0-start&#125; 从 string 字符串的右边第 start 个字符开始截取，直到最后。$&#123;string#*chars&#125; 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。$&#123;string##*chars&#125; 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。$&#123;string%*chars&#125; 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。$&#123;string%%*chars&#125; 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。 实例]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql主从复制和主主复制]]></title>
    <url>%2F2019%2F05%2F16%2Fmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[MySQL5.7服务群集（实现主从复制、读写分离功能） 当业务量非常大时，一台服务器的性能无法满足需求，就可以通过配置主从复制实现读写分离来分摊负载，避免因负载太高而造成无法及时响应请求。 准备工作首先准备两台虚拟机： A 192.168.0.136B 192.168.0.150 并安装好Mysql 配置修改配置文件A 192.168.0.136 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 修改以下配置：123456789101112server-id = 1 #两台服务器不能使用同一个ID log_bin = /var/log/mysql/mysql-bin.logexpire_logs_days = 10max_binlog_size = 100Mauto_increment-increment=2 #自增步长，一般是服务器数量和auto_increment-offset=1 #起始自增数，不要重复#如果是主从，只要主有下面两个replicate_do_db = xtable #复制的库,需要复制的库，多个需要重复此行binlog_do_db = xtable binlog_ignore_db = mysql #不复制的库binlog_ignore_db = information_schema B 192.168.0.150 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 修改以下配置：123456789101112server-id = 2 #两台服务器不能使用同一个ID log_bin = /var/log/mysql/mysql-bin.logexpire_logs_days = 10max_binlog_size = 100Mauto_increment-increment=2auto_increment-offset=2#如果是主从，只要主有下面两个replicate_do_db = xtable #复制的库,需要复制的库，多个需要重复此行binlog_do_db = xtable binlog_ignore_db = mysql #不复制的库binlog_ignore_db = information_schema 保存之后可以将Mysql重启123service mysql restart//查看状态systemctl status mysql.service 连接主从服务器进入主服务器A 192.168.0.1361mysql -uroot -proot master的数据库中建立备份账号：x36为用户名，%表示任何远程地址(可替换成对应的IP)，如下表示密码为123456的任何远程地址的x36都可以连接master主机123grant replication slave on *.* to 'x36'@'%' identified by '123456';#刷新权限FLUSH PRIVILEGES; 查看A MySQL服务器二进制文件名与位置1SHOW MASTER STATUS; 进入从服务器B 192.168.0.1501mysql -uroot -proot 告知主服务的二进制文件名与位置12345stop slave;CHANGE MASTER TO MASTER_HOST='192.168.0.136',MASTER_USER='x36',MASTER_PASSWORD='123456',MASTER_LOG_FILE='mysql-bin.000003',MASTER_LOG_POS=6913;start slave; MASTER_LOG_FILE, MASTER_LOG_POS 对应上面SHOW MASTER STATUS; File,Position 查看slave从机的状态1show slave status \G 显示这两个为Yes，代表成功了Slave_IO_Running: YesSlave_SQL_Running: Yes 接下就在主服务器上生成数据，查看从服务器是否有数据。配置主主就是从服务器和主服务器的配置拿过来]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web负载均衡]]></title>
    <url>%2F2019%2F05%2F15%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Web负载均衡：增加机器来实现分发请求 1、HTTP负载均衡利用代码进行随机重定向 12345678910&lt;?php$domain = array( 'a.com', 'b.com', 'c.com',);$domain = array_rand($domain);header('Location: http://'. $domain); 这个重定向非常容易实现，并且可以自定义各种策略。但是，它在大规模访问量下，性能不佳。而且，给用户的体验也不好，实际请求发生重定向，增加了网络延时。 2、反向代理负载均衡反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。可以做反向代理的软件很多，比较常见的一种是Nginx。 准备两台Nginx服务器：A: 192.168.0.150B: 192.168.0.136 打开A的配置，在http里面加上12345678910upstream nodes &#123; server 192.168.0.136; server 192.168.0.150:8080;&#125;//在server里面修改server_name nodes;location / &#123; proxy_pass http://nodes; try_files $uri $uri/ =404;&#125; 另外配置一个8080端口为应用入口，80做外网端口完了重启就可以了 还有几种策略可以自己选择：1、权重配置：weight=5 ，数字越大请求数量越多2、ip_hash配置：ip_hash; 每一个请求固定落在一个上游服务器，可解决session共享问题，将session这类的信息，专门用某个独立服务来存储，例如redis/memchache，这个方案是比较推荐的。3、fair配置：fair;按上游服务器的响应时间来分配请求。响应时间短的优先分配4、url_hash配置：按照访问的url的hash结果来分配请求，使每一个url定向到同一个上游服务器 反向代理服务，也是可以开启缓存的，如果开启了，会增加反向代理的负担，需要谨慎使用。这种负载均衡策略实现和部署非常简单，而且性能表现也比较好。但是，它有“单点故障”的问题，如果挂了，会带来很多的麻烦。而且，到了后期Web服务器继续增加，它本身可能成为系统的瓶颈。 3、IP负载均衡IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。原理是，他是对IP层的数据包的IP地址和端口信息进行修改，达到负载均衡的目的。这种方式，也被称为“四层负载均衡”。常见的负载均衡方式，是LVS（Linux Virtual Server，Linux虚拟服务），通过IPVS（IP Virtual Server，IP虚拟服务）来实现。 4、DNS负载均衡DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。而一个域名是可以配置成对应多个IP的。因此，DNS也就可以作为负载均衡服务。 这种负载均衡策略，配置简单，性能极佳。但是，不能自由定义规则，而且，变更被映射的IP或者机器故障时很麻烦，还存在DNS生效延迟的问题。 DNS/GSLB负载均衡 我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在同一个域名映射为多IP的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。一般情况下都是按照地理位置，将离用户近的IP返回给用户，减少网络传输中的路由节点之间的跳跃消耗。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构知识体系必读]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%BF%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[参考地址：https://mp.weixin.qq.com/s/ybkenT9uU8SR5roAK9M_0w]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole多进程处理beanstalkd队列]]></title>
    <url>%2F2019%2F03%2F22%2Fswoole%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86beanstalkd%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[安装beanstalkd服务 官网：https://beanstalkd.github.io ubuntu：12sudo apt-get install beanstalkdbeanstalk /etc/init.d/beanstalkd start mac：12345brew install beanstalkd./beanstalkd -l 10.0.1.5 -p 11300 &amp; //后台运行//查看是否开启ps -ef | grep beanstalkd php包：通过composer安装1composer require pda/pheanstalk 安装swoole 参考：https://wiki.swoole.com/wiki/page/6.html github 搜索swoole 克隆到电脑12345https://github.com/swoole/swoole-src.gitcd swoole-srcphpize./configuresudo make &amp;&amp; sudo make install 完了之后配置下php.ini1extension = swoole.so 查看1php -m 生产者，client.php1234567891011121314151617181920212223&lt;?phprequire "vendor/autoload.php";use Pheanstalk\Pheanstalk;//默认端口11300 ， 超时10s$pheanstalk = Pheanstalk::create('127.0.0.1');$data = [ 'name'=&gt;'test', 'time'=&gt; date('Y-m-d H:i:s')];// ----------------------------------------// producer (queues jobs)//往tube中增加数据//put(// 23, // 任务的优先级.// 0, // 不等待直接放到ready队列中.// 60, // 处理任务的时间.// 'hello, beanstalk' // 任务内容//);$pheanstalk -&gt;useTube('testtube') -&gt;put(json_encode($data));//当前管道信息print_r($pheanstalk-&gt;statsTube('testtube')); 消费者, server.php1234567891011121314151617181920212223242526272829303132333435363738&lt;?phprequire "vendor/autoload.php";use Pheanstalk\Pheanstalk;// ----------------------------------------// worker (performs jobs)$workerNum = 10; //进程数$pool = new Swoole\Process\Pool($workerNum);$pool-&gt;on("WorkerStart", function ($pool, $workerId) &#123; echo "Worker#&#123;$workerId&#125; is started\n"; $pheanstalk = Pheanstalk::create('127.0.0.1'); while(true)&#123;// file_put_contents("log.log", "[".time()."] \n", FILE_APPEND); $job = $pheanstalk -&gt;watch('testtube') -&gt;ignore('default') -&gt;reserve(); $data = json_decode($job-&gt;getData()); if($data)&#123; try&#123; print_r($data); handle($data); $pheanstalk-&gt;delete($job); &#125;catch (Exception $e)&#123; $pheanstalk-&gt;release($job); &#125; &#125; &#125;&#125;);$pool-&gt;on("WorkerStop", function ($pool, $workerId) &#123; echo "Worker#&#123;$workerId&#125; is stopped\n";&#125;);$pool-&gt;start();//逻辑代码function handle($data)&#123; for($i=0;$i&lt;10000000;$i++)&#123; &#125;// file_put_contents("log.log", "[".time()."] : ".json_encode($data)."\n", FILE_APPEND);&#125;]]></content>
      <categories>
        <category>swoole 队列 多进程</category>
      </categories>
      <tags>
        <tag>swoole beanstalkd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c扩展]]></title>
    <url>%2F2019%2F03%2F22%2Fc%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[自己编写一个扩展 和 安装一个别人的扩展 源码包1wget http://cn2.php.net/get/php-7.2.16.tar.gz/from/this/mirror 解压12tar -zxvf php-7.2.16.tar.gzcd php-7.2.16/ext/ 完了之后可以看到有很多扩展 开始编写扩展进入扩展目录 php-7.2.16/ext/ PHP的扩展组件开发目录和文件是有固定组织结构的目录下ext_skel脚本就是用来自动构建扩展包框架的工具。ext_skel的完整命令为：1ext_skel --extname=module [--proto=file] [--stubs=file] [--xml[=file]] [--skel=dir] [--full-xml] [--no-help] 我们来创建一个1./ext_skel --extname=hello_world 命令行会提示有编写扩展的步骤这个时候/ext目录下会产生一个hello_world的文件夹 ls查看目录会发现一堆文件 主要的几个文件：config.m4：这是Unix环境下的Build System配置文件，后面将会通过它生成配置和安装。 php_hello_world.h：这个文件是扩展模块的头文件。遵循C语言一贯的作风，这个里面可以放置一些自定义的结构体、全局变量等等。 hello_world.c：这个就是扩展模块的主程序文件了，最终的扩展模块各个函数入口都在这里。当然，你可以将所有程序代码都塞到这里面，也可以遵循模块化思想，将各个功能模块放到不同文件中。 打开生成的config.m4文件，主要内容大致如下： 123456789dnl PHP_ARG_WITH(hello_world, for hello_world support,dnl Make sure that the comment is aligned:dnl [ --with-hello_world Include hello_world support])dnl PHP_ARG_ENABLE(hello_world, whether to enable hello_world support,dnl Make sure that the comment is aligned:dnl [ --enable-hello_world Enable hello_world support]) 上面三行表示 如果你的扩展引用了外部组件，没有就使用下面三行我们先将下面三行的dnl 去掉123PHP_ARG_ENABLE(hello_world, whether to enable hello_world support,Make sure that the comment is aligned:[ --enable-hello_world Enable hello_world support]) 保存 编写自己的函数，打开hello_world.c找到下面这部分代码12345const zend_function_entry myext_functions[] = &#123; PHP_FE(confirm_myext_compiled, NULL) /* For testing, remove later. */ PHP_FE(hello_world, NULL) //这个是新加上去的，函数名自己一定，我这边叫hello_world PHP_FE_END /* Must be the last line in myext_functions[] */&#125;; 实现函数找到confirm_myext_compiled这个函数的位置，将新写的函数写在一起12345PHP_FUNCTION(hello_world)&#123; php_printf(&quot;Hello World!\n&quot;); RETRUN_TRUE;&#125; 保存ok，搞完了，开始编译安装吧 在刚刚的目录下 ext/hello_world执行123phpize./configuresudo make &amp;&amp; sudo make install 好了，完了之后配置下php.ini1sudo vim /usr/local/php/php.ini 修改下扩展的目录，添加扩展1234extension_dir = &quot;/usr/local/php/lib/php/extensions/no-debug-non-zts-20170718/&quot; //刚刚扩展安装完了之后会显示位置extension = hello_world.so 重启php-fpm1sudo /etc/init.d/php-fpm restart 执行php -r &quot;hello_world();&quot;，输出Hello World!! 安装一个redis扩展下载源码包github 搜索phpredis 克隆到电脑12345git clone https://github.com/phpredis/phpredis.gitcd phpredisphpize./configuresudo make &amp;&amp; sudo make install 完了之后配置下php.ini1extension = redis.so 查看1php -m over]]></content>
      <categories>
        <category>C扩展</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC安装nginx php]]></title>
    <url>%2F2019%2F03%2F22%2FMAC%E5%AE%89%E8%A3%85nginx-php%2F</url>
    <content type="text"><![CDATA[phpphp安装下载源码包1wget http://cn2.php.net/get/php-7.2.16.tar.gz/from/this/mirror 如果没有wget就先安装wget1brew install wget 解压12tar -zxvf php-7.2.16.tar.gzcd php-7.2.16 编译 ./configure –prefix=/usr/local/php –with-config-file-path=/usr/local/php –enable-mbstring –enable-ftp –with-gd –with-jpeg-dir=/usr –with-png-dir=/usr –with-mysql=mysqlnd –with-mysqli=mysqlnd –with-pdo-mysql=mysqlnd –with-pear –enable-sockets –with-freetype-dir=/usr –with-zlib –with-libxml-dir=/usr –with-xmlrpc –enable-zip –enable-fpm –enable-xml –enable-sockets –with-gd –with-zlib –with-iconv –enable-zip –with-freetype-dir=/usr/lib/ –enable-soap –enable-pcntl –enable-cli –with-curl 说明：由于PHP7.2不再支持mysql，而是用mysqli取代。因此会出现上面图中所示的warning。不过没关系，如果需要安装php的mysql扩展，文章后面会有说明。 编译完成之后，执行安装命令： 1sudo make &amp;&amp; sudo make install 安装过程大约需要20分钟时间，耐心等待 开始配置在之前编译的源码包中，找到 php.ini-production，复制到/usr/local/php下，并改名为php.ini： 1cp php.ini-production /usr/local/php/php.ini 复制启动脚本：12cp ./sapi/fpm/init.d.php-fpm /etc/init.d/php-fpmchmod +x /etc/init.d/php-fpm 修改php-fpm配置文件：123cd /usr/local/php/etccp php-fpm.conf.default php-fpm.confvim php-fpm.conf 去掉 php-fpm.conf 中 pid = run/php-fpm.pid 前面的分号 12cd php-fpm.dcp www.conf.default www.conf 默认配置可不做修改 【启动PHP】123/etc/init.d/php-fpm start #php-fpm启动命令/etc/init.d/php-fpm stop #php-fpm停止命令/etc/init.d/php-fpm restart #php-fpm重启命令 nginxnginx安装1brew install nginx 安装默认位置1/usr/local/Cellar/nginx/1.13.9/ 启动命令1sudo nginx -s reload 配置相关东西1sudo vim /usr/local/etc/nginx/nginx.conf 如果没有就cp一份1sudo cp /usr/local/etc/nginx/nginx.conf.default /usr/local/etc/nginx/nginx.conf 打开配置文件编辑 主要是几个地方1234去掉注释的地方user nobody; error_log logs/error.log; 打开错误日志，位置在：/usr/local/Cellar/nginx/1.13.9/logs 里面pid logs/nginx.pid; 位置在：/usr/local/Cellar/nginx/1.13.9/logs 里面 然后是 http server 里面的配置 默认监听的是8080端口，因为apache是80端口这里我把他修改成80端口，先关闭apache1234567891011121314sudo apachectl stoplisten 80;charset utf-8;root [网站跟目录] //root放到server下一级，记得设置权限location /&#123; index index.html index.htm index.php;&#125;//这里面的注释全部打开，默认监听9000端口，Php-fpm默认是9000location ~\.php$&#123; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; //这里有一处改动，/script 替换成 $document_root （根目录）&#125; 好了，暂时先不修改其他东西 重启nginx 和 php-fpm12sudo nginx -s reloadsudo /etc/init.d/php-fpm restart 然后在根目录创建一个phpinfo.php 如果有页面显示就ok了 ################ 相关错误： 打开网页显示 file not found1、文件不存在2、server下 root 没有对应好3、权限问题]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩Ubuntu]]></title>
    <url>%2F2019%2F02%2F18%2F%E7%8E%A9Ubuntu%2F</url>
    <content type="text"><![CDATA[主要玩一下Lnmp 安装和配置虚拟机1、下载虚拟机下载免费的虚拟机： virtualbox 傻瓜式安装，并提前下载好Ubuntu镜像，官方网站 2、配置点击设置 -&gt; 网络 -&gt; 连接方式 设置成桥接网卡并选择网卡 新建一个虚拟机，并安装镜像 安装Lnmp1、使用windows的bash连接虚拟机查看本机IP1ipconfig 如果报错：安装net-tools 1sudo apt-get install net-tools 安装openssh-server1sudo apt-get install openssh-server 到windows上，我使用的Git Bash 连接到虚拟机123ssh [username]@[ip]如：ssh zhangsan@192.168.1.150 输入密码之后进行连接 2、安装nginx更新，切换到root 123sudo su 回车输入密码并进入root用户apt-get update 安装Nginx1apt-get install nginx 能打开localhost即安装成功 3、安装php7.2安装7.21apt-get install php7.2 安装扩展1apt-get install php7.2-mysql php7.2-fpm php7.2-curl php7.2-xml php7.2-gd php7.2-mbstring php-memcached php7.2-zip 3、配置nginx和php1vim /etc/nginx/sites-available/default 修改为1234567891011121314server &#123; listen 80 default_server; listen [::]:80 default_server; root /home/xi/www/; index index.html index.htm index.php; server_name localhost; location / &#123; try_files $uri $uri/ =404; &#125; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; &#125;&#125; 重启nginx1service nginx restart 4、安装mysql123apt-get install mysql-serverapt-get isntall mysql-clientapt-get install libmysqlclient-dev 安装完成之后访问1mysql -u root -p 创建用户 1CREATE USER 'username'@'host' IDENTIFIED BY 'password'; 说明：123username：你将创建的用户名host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 例子：123CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';CREATE USER 'pig'@'192.168.1.101' IDENDIFIED BY '123456';CREATE USER 'pig'@'%' IDENTIFIED BY '123456'; 授权1GRANT privileges ON databasename.tablename TO 'username'@'host' 说明：123privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALLdatabasename：数据库名tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.* 例子：123GRANT SELECT, INSERT ON test.user TO 'pig'@'%';GRANT ALL ON *.* TO 'pig'@'%';GRANT ALL ON maindataplus.* TO 'pig'@'%'; 注意:用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:1GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION; 删除用户1DROP USER 'username'@'host';]]></content>
      <categories>
        <category>Ubuntu, Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu, Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo迁移]]></title>
    <url>%2F2019%2F02%2F15%2Fhexo%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[快速开始备份之前的配置文件和文章123/_config.yml/themes/next/_config.yml/source/* 开始迁移在新电脑上操作，先安装node、git、hexo，参考《用Hexo在本地搭建一个博客》这篇文章 1、新建项目1hexo init hexo 2、下载next主题12cd hexogit clone https://github.com/iissnan/hexo-theme-next themes/next 3、替换配置文件和资源目录123/_config.yml/themes/next/_config.yml/source/* 4、安装hexo-deployer-git1npm install hexo-deployer-git --save 5、生成静态文件并部署到网站1hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓淘宝天猫京东商品数据]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%8A%93%E6%B7%98%E5%AE%9D%E5%A4%A9%E7%8C%AB%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[快速开始获取composer包phantomjs 可以获取网页加载完之后的数据dom-crawler 解析domcss-selector css解析器 123&quot;jonnyw/php-phantomjs&quot;: &quot;4.*&quot;,&quot;symfony/dom-crawler&quot;: &quot;^4.1&quot;,&quot;symfony/css-selector&quot;: &quot;^4.1&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?phpinclude &apos;./vendor/autoload.php&apos;;set_time_limit(0);use Symfony\Component\DomCrawler\Crawler;use JonnyW\PhantomJs\Client;##### 天猫 #####/*//$url = &apos;https://detail.tmall.com/item.htm?id=566603286049&apos;;//天猫//$url = &apos;https://detail.tmall.com/item.htm?id=573608760172&apos;;//天猫$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);//天猫会重定向，设置允许重定向curl_setopt($ch, CURLOPT_FOLLOWLOCATION, TRUE);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);$html = curl_exec($ch);curl_close($ch);//解析$crawler = new Crawler();$crawler-&gt;addHtmlContent($html);//转乱码$html = iconv(&quot;GBK&quot;,&quot;UTF-8&quot;, $html);$data[&apos;title&apos;] = trim($crawler-&gt;filter(&apos;.tb-detail-hd h1&apos;)-&gt;text());$data[&apos;share_title&apos;] = trim($crawler-&gt;filter(&apos;.tb-detail-hd p&apos;)-&gt;text());$regex4=&quot;/\&quot;defaultItemPrice\&quot;:\&quot;.*?\&quot;.*?/ism&quot;;if(preg_match_all($regex4, $html, $matches))&#123; $data[&apos;price&apos;] = trim(explode(&apos;:&apos;, $matches[0][0])[1], &apos;&quot;&apos;);&#125;$data[&apos;img&apos;] = $crawler-&gt;filter(&apos;#J_ImgBooth&apos;)-&gt;attr(&apos;src&apos;);foreach($crawler-&gt;filter(&apos;.tb-sku dl&apos;) as $key =&gt; $val)&#123; if($val-&gt;getElementsByTagName(&apos;dt&apos;)-&gt;count() != 0)&#123; $data[&apos;attr&apos;.$key][&apos;name&apos;] = $val-&gt;getElementsByTagName(&apos;dt&apos;)-&gt;item(0)-&gt;textContent; if($data[&apos;attr&apos;.$key][&apos;name&apos;] == &apos;数量&apos;)&#123; unset($data[&apos;attr&apos;.$key]); break; &#125; for($i=0; $i&lt; $val-&gt;getElementsByTagName(&apos;li&apos;)-&gt;count(); $i++)&#123; $data[&apos;attr&apos;.$key][&apos;value&apos;][] = trim($val-&gt;getElementsByTagName(&apos;li&apos;)-&gt;item($i)-&gt;textContent); &#125; &#125;&#125;//品牌// $data[&apos;brand&apos;] = $crawler-&gt;filter(&apos;#J_EbrandLogo&apos;)-&gt;text();//参数规格foreach($crawler-&gt;filter(&apos;#attributes #J_AttrUL li&apos;) as $val)&#123; $data[&apos;parameter&apos;][] = $val-&gt;textContent;&#125;$data[&apos;desc&apos;] = &apos;&apos;;$regex4=&quot;/\&quot;httpsDescUrl\&quot;:\&quot;.*?\&quot;.*?/ism&quot;;if(preg_match_all($regex4, $html, $matches))&#123; $url = &apos;https:&apos;.trim(explode(&apos;:&apos;, $matches[0][0])[1], &apos;&quot;&apos;); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, TRUE); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE); $desc = curl_exec($ch); curl_close($ch); $desc = substr($desc, 10, -3); $data[&apos;desc&apos;] = $desc;&#125;p($data);*/##### 天猫 ########## 淘宝 #####/*$url = &apos;https://item.taobao.com/item.htm?id=574833149385&apos;;//淘宝$client = Client::getInstance();//默认情况下，PhantomJS库将在bin文件夹中查找相对于脚本运行位置〜/ bin / phantomjs的PhantomJS可执行文件。 如果找不到可执行文件或者PhantomJS可执行文件的路径与默认位置不同，例如您已全局安装PhantomJS，则需要手动定义PhantomJS可执行文件的路径。$client-&gt;getEngine()-&gt;setPath(&apos;E:\work\phantomjs\bin\phantomjs.exe&apos;);//获取数据$request = $client-&gt;getMessageFactory()-&gt;createRequest($url, &apos;GET&apos;);$response = $client-&gt;getMessageFactory()-&gt;createResponse();$client-&gt;send($request, $response);//获取数据$html = $response-&gt;getContent();//解析$crawler = new Crawler();$crawler-&gt;addHtmlContent($html);$data[&apos;title&apos;] = trim($crawler-&gt;filter(&apos;.tb-main-title&apos;)-&gt;text());$data[&apos;original_price&apos;] = $crawler-&gt;filter(&apos;#J_StrPriceModBox .tb-rmb-num&apos;)-&gt;text();// $data[&apos;price&apos;] = $crawler-&gt;filter(&apos;#J_PromoPrice .tb-rmb-num&apos;)-&gt;text();$data[&apos;img&apos;] = $crawler-&gt;filter(&apos;#J_ImgBooth&apos;)-&gt;attr(&apos;src&apos;);foreach($crawler-&gt;filter(&apos;#J_isku .J_Prop&apos;) as $key =&gt; $val)&#123; $data[&apos;attr&apos;.$key][&apos;name&apos;] = $val-&gt;getElementsByTagName(&apos;ul&apos;)-&gt;item(0)-&gt;getAttribute(&apos;data-property&apos;); for($i=0; $i&lt; $val-&gt;getElementsByTagName(&apos;a&apos;)-&gt;count(); $i++)&#123; $data[&apos;attr&apos;.$key][&apos;value&apos;][] = trim($val-&gt;getElementsByTagName(&apos;a&apos;)-&gt;item($i)-&gt;textContent); &#125;&#125;//参数规格foreach($crawler-&gt;filter(&apos;#attributes li&apos;) as $val)&#123; $data[&apos;parameter&apos;][] = trim($val-&gt;textContent);&#125;foreach($crawler-&gt;filter(&apos;#description img&apos;) as &amp;$val)&#123; if($val-&gt;getAttribute(&apos;data-ks-lazyload&apos;))&#123; $val-&gt;setAttribute(&apos;src&apos;, $val-&gt;getAttribute(&apos;data-ks-lazyload&apos;)); &#125;&#125;$data[&apos;desc&apos;] = $crawler-&gt;filter(&apos;#description&apos;)-&gt;html();p($data);*/##### 淘宝 ########## 京东 #####$url = &apos;https://item.jd.com/27318172889.html&apos;; //京东$client = Client::getInstance();//默认情况下，PhantomJS库将在bin文件夹中查找相对于脚本运行位置〜/ bin / phantomjs的PhantomJS可执行文件。 如果找不到可执行文件或者PhantomJS可执行文件的路径与默认位置不同，例如您已全局安装PhantomJS，则需要手动定义PhantomJS可执行文件的路径。$client-&gt;getEngine()-&gt;setPath(&apos;E:\work\phantomjs\bin\phantomjs.exe&apos;);//获取数据$request = $client-&gt;getMessageFactory()-&gt;createRequest($url, &apos;GET&apos;);$response = $client-&gt;getMessageFactory()-&gt;createResponse();$client-&gt;send($request, $response);//获取数据$html = $response-&gt;getContent();//解析$crawler = new Crawler();$crawler-&gt;addHtmlContent($html);$data[&apos;title&apos;] = trim($crawler-&gt;filter(&apos;.sku-name&apos;)-&gt;text());$data[&apos;price&apos;] = $crawler-&gt;filter(&apos;.summary-price-wrap .price&apos;)-&gt;text();$data[&apos;img&apos;] = &apos;https:&apos;.$crawler-&gt;filter(&apos;#spec-img&apos;)-&gt;attr(&apos;src&apos;);//属性for($i=1; $i&lt;10; $i++)&#123; if($crawler-&gt;filter(&apos;#choose-attr-&apos;.$i)-&gt;count() == 0) break; $data[&apos;attr&apos;.$i][&apos;name&apos;] = $crawler-&gt;filter(&apos;#choose-attr-&apos;.$i)-&gt;attr(&apos;data-type&apos;); foreach($crawler-&gt;filter(&apos;#choose-attr-&apos;.$i.&apos; .item&apos;) as $val)&#123; $data[&apos;attr&apos;.$i][&apos;value&apos;][] = $val-&gt;getAttribute(&apos;data-value&apos;); &#125;&#125;//参数规格foreach($crawler-&gt;filter(&apos;.parameter1 p&apos;) as $val)&#123; $data[&apos;parameter1&apos;][] = $val-&gt;textContent;&#125;foreach($crawler-&gt;filter(&apos;.parameter2 li&apos;) as $val)&#123; $data[&apos;parameter2&apos;][] = $val-&gt;textContent;&#125;//品牌$data[&apos;brand&apos;] = $crawler-&gt;filter(&apos;#parameter-brand a&apos;)-&gt;text();//详情$data[&apos;desc&apos;] = $crawler-&gt;filter(&apos;#J-detail-content&apos;)-&gt;html();$data[&apos;desc&apos;] = str_replace(&apos;data-lazyload=&quot;&apos;, &apos;src=&quot;https://&apos;, $data[&apos;desc&apos;]);p($data);##### 京东 #####]]></content>
      <tags>
        <tag>phantomjs, php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Laravel 扩展包 TOP 250]]></title>
    <url>%2F2018%2F11%2F23%2FGitHub-Laravel-%E6%89%A9%E5%B1%95%E5%8C%85-TOP-250%2F</url>
    <content type="text"><![CDATA[请跳转：https://laravel-china.org/projects/filter/laravel-top250]]></content>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪实时股票数据接口]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%96%B0%E6%B5%AA%E5%AE%9E%E6%97%B6%E8%82%A1%E7%A5%A8%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[股票数据的获取目前有如下两种方法可以获取： http/javascript接口取数据 web-service接口 1.http/javascript接口取数据1.1Sina股票数据接口以大秦铁路（股票代码：601006）为例，如果要获取它的最新行情，只需访问新浪的股票数据接口：http://hq.sinajs.cn/list=sh601006这个url会返回一串文本，例如：var hq_str_sh601006=”大秦铁路, 27.55, 27.25, 26.91, 27.55, 26.20,26.91, 26.92,22114263, 589824680, 4695, 26.91, 57590, 26.90, 14700, 26.89,14300,26.88, 15100, 26.87, 3100, 26.92, 8900, 26.93, 14230, 26.94, 25150,26.95, 15220, 26.96, 2008-01-11, 15:05:32”;这个字符串由许多数据拼接在一起，不同含义的数据用逗号隔开了，按照程序员的思路，顺序号从0开始。0：”大秦铁路”，股票名字；1：”27.55″，今日开盘价；2：”27.25″，昨日收盘价；3：”26.91″，当前价格；4：”27.55″，今日最高价；5：”26.20″，今日最低价；6：”26.91″，竞买价，即“买一”报价；7：”26.92″，竞卖价，即“卖一”报价；8：”22114263″，成交的股票数，由于股票交易以一百股为基本单位，所以在使用时，通常把该值除以一百；9：”589824680″，成交金额，单位为“元”，为了一目了然，通常以“万元”为成交金额的单位，所以通常把该值除以一万；10：”4695″，“买一”申请4695股，即47手；11：”26.91″，“买一”报价；12：”57590″，“买二”13：”26.90″，“买二”14：”14700″，“买三”15：”26.89″，“买三”16：”14300″，“买四”17：”26.88″，“买四”18：”15100″，“买五”19：”26.87″，“买五”20：”3100″，“卖一”申报3100股，即31手；21：”26.92″，“卖一”报价(22, 23), (24, 25), (26,27), (28, 29)分别为“卖二”至“卖四的情况”30：”2008-01-11″，日期；31：”15:05:32″，时间；一个简单的JavaScript应用例子: 这段代码输出大秦铁路（股票代码：601006）的当前股价current price:14.20如果你要同时查询多个股票，那么在URL最后加上一个逗号，再加上股票代码就可以了；比如你要一次查询大秦铁路（601006）和大同煤业（601001）的行情，就这样使用URL：http://hq.sinajs.cn/list=sh601003,sh601001查询大盘指数，比如查询上证综合指数（000001）：http://hq.sinajs.cn/list=s_sh000001服务器返回的数据为：varhq_str_s_sh000001=”上证指数,3094.668,-128.073,-3.97,436653,5458126”;数据含义分别为：指数名称，当前点数，当前价格，涨跌率，成交量（手），成交额（万元）；查询深圳成指数：http://hq.sinajs.cn/list=s_sz399001对于股票的K线图，日线图等的获取可以通过请求http://image.sinajs.cn/…./…/*.gif此URL获取，其中*代表股票代码，详见如下：查看日K线图：http://image.sinajs.cn/newchart/daily/n/sh601006.gif 分时线的查询：http://image.sinajs.cn/newchart/min/n/sh000001.gif 日K线查询：http://image.sinajs.cn/newchart/daily/n/sh000001.gif 周K线查询：http://image.sinajs.cn/newchart/weekly/n/sh000001.gif 月K线查询：http://image.sinajs.cn/newchart/monthly/n/sh000001.gif 1.2Baidu&amp;Google的财经数据在baidu,google中搜索某只股票代码时，将会在头条显示此股票的相关信息，例如在google搜索601006时，第一条搜索结果如下图：通过点击左边的图片我们发现会将此图片链接到sina财经频道上，也就是说google股票数据的获取也是从sina获取。后经抓包分析，发现google也是采用1.1中介绍的接口。Baidu的股票数据来自baidu的财经频道http://stock.baidu.com/1.3 其他方式除了sina，baidu等网站提供股票信息外，其他网站也有类似的接口。我们分析了一款论坛上采用的股票插件，其中有关于实时股票数据获取的介绍，详见如下代码，其中可以看到有些数据来自sina。以下是ASP示例:=5 thenstockdata=gethttp(“http://hq.sinajs.cn/list=sh&quot;&amp;code&amp;&quot;&quot;)if not len(stockdata)=0 thenstockdata=split(stockdata,chr(34))(1)end ifif len(stockdata)=0 thenstockdata=”0,0,0,0,0,0,0,0,0,0,0,0”elsestockdatasplit=split(stockdata,”,”)stockdata=””&amp;exstock.checkstr(stockdatasplit(0))&amp;”,”&amp;stockdatasplit(1)&amp;”,”&amp;stockdatasplit(2)&amp;”,”&amp;stockdatasplit(3)&amp;”,”&amp;stockdatasplit(4)&amp;”,”&amp;stockdatasplit(5)&amp;”,”&amp;formatdatetime(“”&amp;stockdatasplit(30)&amp;””&amp;stockdatasplit(31)&amp;””,0)&amp;””end if‘0=股票名称,1=开盘价格,2=昨收盘价格,3=当前价格,4=最高价,5=最低价,6=更新时间getstockdata=stockdataend functionfunction getstockimg(code)dim rndnum,addnum,checkcode,imgsourceif len(code)=5 thengetstockimg=”http://image.sinajs.cn/newchart/daily/n/sh&quot;&amp;code&amp;&quot;.gif&quot;end ifimgsource=”http://finance.sina.com.cn&quot;case 3getstockimg=”http://hq.gazxfe.com/stockchart/realline.chart?&quot;&amp;code&amp;&quot;&amp;1003&amp;SZ500 330”imgsource=”http://hq.gazxfe.com&quot;case 4getstockimg=”http://chartse.stockstar.com/chartserver?code=&quot;&amp;code&amp;&quot;&quot;imgsource=”http://www.stockstar.com/&quot;end selectgetstockimg=split(“”&amp;getstockimg&amp;”||”&amp;imgsource&amp;””,”||”)end functionfunction getastockimg()dim rndnum,addnum,checkcodedim getastockimgb,imgsourceaddnum=6randomize:rndnum=cint(rnd*addnum)select case rndnumcase 0getastockimg=”http://202.109.106.1/gifchartse/gif/000001.gif&quot;getastockimgb=”http://202.109.106.1/gifchartse/gif/399001.gif&quot;imgsource=”http://www.stockstar.com/&quot;case 1getastockimg=”http://money.163.com/special/100.gif?C39&quot;getastockimgb=”http://money.163.com/special/101.gif?HrS&quot;imgsource=”http://www.163.com&quot;case 2getastockimg=”http://www.10jqka.com.cn/curve/realtime/index2.php?code=1a0001&amp;w=180&amp;h=140&quot;getastockimgb=”http://www.10jqka.com.cn/curve/realtime/index2.php?code=399001&amp;w=180&amp;h=140&quot;imgsource=”http://www.10jqka.com.cn&quot;case 3getastockimg=”http://chart.cnlist.com/stockchart/realline.chart?1a0001&amp;1002&amp;SZ180 140”getastockimgb=”http://chart.cnlist.com/stockchart/realline.chart?399001&amp;1002&amp;SZ180 140”imgsource=”http://chart.cnlist.com/&quot;case 4getastockimg=”http://image.sinajs.cn/newchart/small/ish000001.gif?1189176558328&quot;getastockimgb=”http://image.sinajs.cn/newchart/small/isz399001.gif?1189176558328&quot;imgsource=”http://www.sinajs.cn&quot;case 5getastockimg=”http://218.1.72.66/cgi/pic/sh/realtime/JA000001164143.png&quot;getastockimgb=”http://218.1.72.66/cgi/pic/sz/realtime/JA399001164143.png&quot;imgsource=”http://www.cnstock.com/&quot;case 6getastockimg=”http://222.73.29.85/img/000001.png&quot;getastockimgb=”http://222.73.29.85/img/399001.png&quot;imgsource=”http://www.eastmoney.com/&quot;end selectgetastockimg=split(“”&amp;getastockimg&amp;”||”&amp;getastockimgb&amp;”||”&amp;imgsource&amp;””,”||”)end function%&gt; web-service接口2.1 CHINAstock的web-service：http://www.webxml.com.cn/WebServices/ChinaStockWebService.asmx中国股票行情数据 WEB 服务（支持深圳和上海股市的全部基金、债券和股票），数据即时更新。输出GIF分时走势图、日/周/月 K线图、及时行情数据（股票名称、行情时间、最新价、昨收盘、今开盘、涨跌额、最低、最高、涨跌幅、成交量、成交额、竞买价、竞卖价、委比、买一- 买五、卖一 - 卖五）。此WEB服务提供了如下几个接口：2.1.1 getStockImageByCodeGET 股票GIF分时走势图INput：theStockCode = 股票代号，如：sh000001POST /WebServices/ChinaStockWebService.asmx HTTP/1.1Host: www.webxml.com.cnContent-Type: text/xml; charset=utf-8Content-Length: lengthSOAPAction: http://WebXml.com.cn/getStockImageByCode string Output：2.1.2 getStockImageByteByCode获得中国股票GIF分时走势图字节数组INput：theStockCode = 股票代号，如：sh000001POST /WebServices/ChinaStockWebService.asmx HTTP/1.1Host:www.webxml.com.cnContent-Type: text/xml;charset=utf-8Content-Length: lengthSOAPAction:”http://WebXml.com.cn/getStockImageByteByCode&quot; string返回的数据如下：R0lGODlhIQIsAfcAAAAAAAwLBxkGBQ4ODhAQEBsSChUVFS4TDB8eGQkA9koPCDAAzy4mFVgAp2UYC0IqEUYuBVwiDEAsI1QnFX8AgDU1NUozFlgxD6cBWVY5FnIwEmQ4Gc0AMlhDHPEADlVJMEpKSm1IHOUBWpY3FZMyVY9IGXRWIEFmWGNYUmpdPXJgHQB8HK9EGGBgX4lXIACoAHhkMyt4m4VkJtstbv8A2.1.3 getStockImage_kByCode直接获得中国股票GIF日/周/月 K 线图（545*300pixel/72dpi）INPUT: theStockCode = 股票代号theType = K 线图类型（D：日[默认]、W：周、M：月），POST /WebServices/ChinaStockWebService.asmx HTTP/1.1Host:www.webxml.com.cnContent-Type: text/xml;charset=utf-8Content-Length: lengthSOAPAction:”http://WebXml.com.cn/getStockImage_kByCode&quot; string string比如按照下图所示输入：返回的结果就是周K线图：2.1.4 getStockImage_kByteByCode获得中国股票GIF日/周/月 K 线图字节数组Input：theStockCode = 股票代号，如：sh000001POST /WebServices/ChinaStockWebService.asmx HTTP/1.1Host:www.webxml.com.cnContent-Type: text/xml;charset=utf-8Content-Length: lengthSOAPAction:”http://WebXml.com.cn/getStockImage_kByteByCode&quot; string stringHTTP/1.1 200 OKContent-Type: text/xml; charset=utf-8Content-Length:length base64Binary比如按照下图输入：返回的结果就是周K线图字节数组R0lGODlhIQIsAfcAAAAAAAwLBxkGBQ4ODhAQEBsSChUVFS4TDB8eGQkA9koPCDAAzy4mFVgAp2UYC0IqEUYuBVwiDEAsI1QnFX8AgDU1NUozFlgxD6cBWVY5FnIwEmQ4Gc0AMlhDHPEADlVJMEpKSm1IHOUBWpY3FZMyVY9IGXRWIEFmWGNYUmpdPXJgHQB8HK9EGGBgX4lXIACoAHhkMyt4m4VkJtstbv8A2.1.5 getStockInfoByCode获得中国股票及时行情input：theStockCode = 股票代号POST /WebServices/ChinaStockWebService.asmx HTTP/1.1Host:www.webxml.com.cnContent-Type: text/xml;charset=utf-8Content-Length: lengthSOAPAction:”http://WebXml.com.cn/getStockInfoByCode&quot; string返回的值一个一维字符串数组String(24)，结构为：String(0)股票代号、String(1)股票名称、String(2)行情时间、String(3)最新价（元）、String(4)昨收盘（元）、String(5)今开盘（元）、String(6)涨跌额（元）、String(7)最低（元）、String(8)最高（元）、String(9)涨跌幅（%）、String(10)成交量（手）、String(11)成交额（万元）、String(12)竞买价（元）、String(13)竞卖价（元）、String(14)委比（%）、String(15)-String(19)买一- 买五（元）/手、String(20)-String(24)卖一 - 卖五（元）/手。Webservice的方法类似于现在concurrent项目的DBWS数据的获取，都是通过SOAP协议向DBWS服务器获取相关的数据。利用雅虎查中国股票http://quote.yahoo.com/d/quotes.csv?s=MSFT&amp;f=slc1wop返回微软的股票价格“MSFT”,”4:00pm - 30.70”,+1.04,”21.46 -30.75”,29.77,29.66http://quote.yahoo.com/d/quotes.csv?s=000969.SZ&amp;f=slc1wop这个返回安泰科技的，一般有半个小时的延迟。但是s=000969.sz 这个后面的sz是深圳的意思, 沪市是SS后缀 另附： sinajs 接口中获取各大股指的详细代码 深成指：上证指：道琼斯：纳斯达克：恒生指：日经指数：台湾加权：新加坡： 详细用法参考sinajs使用方法！ 参考方法： 新浪期货数据接口 实时数据【例子】http://hq.sinajs.cn/list=M0豆粕连续 M0 返回值如下：varhq_str_M0=”豆粕连续,145958,3170,3190,3145,3178,3153,3154,3154,3162,3169,1325,223,1371608,1611074,连,豆粕,2013-06-28”; 查看 http://finance.sina.com.cn/futures/quotes/M0.shtml页面，发现含义如下： 最新价: 3154 开盘价: 3170 最高价: 3190 最低价: 3145结算价: 3162 昨结算: 3169 持仓量: 1371608 成交量: 1611074买 价: 3153 卖 价: 3154 买 量: 1325 卖 量: 223 这个字符串由许多数据拼接在一起，不同含义的数据用逗号隔开了，按照程序员的思路，顺序号从0开始。0：豆粕连续，名字1：145958，不明数字（难道是数据提供商代码？）2：3170，开盘价3：3190，最高价4：3145，最低价5：3178，昨日收盘价 （2013年6月27日）6：3153，买价，即“买一”报价7：3154，卖价，即“卖一”报价8：3154，最新价，即收盘价9：3162，结算价10：3169，昨结算11：1325，买 量12：223，卖 量13：1371608，持仓量14：1611074，成交量15：连，大连商品交易所简称16：豆粕，品种名简称17：2013-06-28，日期 新浪期货数据各品种代码（商品连续）如下 RB0 螺纹钢 AG0 白银 AU0 黄金 CU0 沪铜 AL0 沪铝 ZN0 沪锌 PB0 沪铅 RU0 橡胶 FU0 燃油 WR0 线材 A0 大豆 M0 豆粕 Y0 豆油 J0 焦炭 C0 玉米 L0 乙烯 P0 棕油 V0 PVC RS0 菜籽 RM0 菜粕 FG0 玻璃 CF0 棉花 WS0 强麦 ER0 籼稻 ME0 甲醇 RO0 菜油 TA0 甲酸 CFF_RE_IF1307 股指期货好像没有期指连续 品种名 + 0 （数字0），代表品种连续，如果是其他月份，请使用品种名 + YYYMM 例如豆粕 2013年09月，M1309 http://hq.sinajs.cn/list=M1309 一次可以请求多个品种，例如 http://hq.sinajs.cn/list=CFF_RE_IF1307,TA0,M0,CFF_RE_IF1306,RB1309,M1309,SR1309,TA1309,Y1309,P1309,C1309,FG1309,WS1309,A1309,L1309,CF1309,CU1303 返回值 varhq_str_CFF_RE_IF1307=”2116,2217.8,2098,2168.6,1253068,808746000000,59806,2168.6,2144.6,2331.4,1907.8,,,2119,2119.6,70151,0,0,–,–,–,–,–,–,–,–,0,0,–,–,–,–,–,–,–,–,2013-06-28,15:33:30,0”;var hq_str_TA0=”甲酸连续,145956,7842,7848,7774,7844,7826,7828,7826,7814,7836,19,22,472758,205716,郑,甲酸,2013-06-28”;varhq_str_M0=”豆粕连续,145958,3170,3190,3145,3178,3153,3154,3154,3162,3169,1325,223,1371608,1611074,连,豆粕,2013-06-28”;varhq_str_CFF_RE_IF1306=”2312.8,2322.6,2277.6,2315.6,57266,39596400000,0,2315.6,2315,2797.4,1865,,,2329.8,2331.2,13893,0,0,–,–,–,–,–,–,–,–,0,0,–,–,–,–,–,–,–,–,2013-06-21,15:38:30,0”;var hq_str_RB1309=”螺钢1309,145957,3422,3468,3422,3440,3449,3452,3449,3447,3429,10,2,3750,3510,沪,螺钢,2013-06-28”;varhq_str_M1309=”豆粕1309,145958,3495,3512,3455,3488,3460,3461,3460,3478,3500,330,228,784354,519734,连,豆粕,2013-06-28”;varhq_str_SR1309=”白糖1309,145956,5172,5194,5165,5189,5192,5193,5192,5179,5184,5,198,334854,65036,郑,白糖,2013-06-28”;varhq_str_TA1309=”甲酸1309,145956,7842,7848,7774,7844,7826,7828,7826,7814,7836,19,22,472758,205716,郑,甲酸,2013-06-28”;varhq_str_Y1309=”豆油1309,145958,7120,7190,7112,7150,7150,7156,7152,7164,7140,55,42,318796,97838,连,豆油,2013-06-28”;varhq_str_P1309=”棕油1309,145956,5760,5828,5760,5786,5782,5784,5784,5798,5780,21,3,235638,67818,连,棕油,2013-06-28”;varhq_str_C1309=”玉米1309,145957,2417,2425,2415,2418,2418,2419,2418,2419,2413,43,95,427232,57906,连,玉米,2013-06-28”;varhq_str_FG1309=”玻璃1309,145956,1371,1378,1365,1372,1371,1372,1371,1372,1369,2,336,203932,184978,郑,玻璃,2013-06-28”;varhq_str_WS1309=”强麦1309,145955,2557,2558,2536,2552,2537,2538,2537,2543,2556,6,31,37406,14254,郑,强麦,2013-05-14”;varhq_str_A1309=”豆一1309,145946,4789,4792,4784,4791,4789,4790,4789,4789,4789,4,26,64086,5938,连,豆一,2013-06-28”;varhq_str_L1309=”乙烯1309,145958,10440,10485,10390,10440,10400,10405,10405,10440,10400,321,8,241618,188036,连,乙烯,2013-06-28”;varhq_str_CF1309=”棉花1309,145954,20435,20470,20390,20445,20390,20415,20390,20440,20425,76,5,27778,2188,郑,棉花,2013-06-28”;var hq_str_CU1303=””; 历史数据 新浪期货数据各品种代码（商品连续）如下 RB0 螺纹钢 AG0 白银 AU0 黄金 CU0 沪铜 AL0 沪铝 ZN0 沪锌 PB0 沪铅 RU0 橡胶 FU0 燃油 WR0 线材 A0 大豆 M0 豆粕 Y0 豆油 J0 焦炭 C0 玉米 L0 乙烯 P0 棕油 V0 PVC RS0 菜籽 RM0 菜粕 FG0 玻璃 CF0 棉花 WS0 强麦 ER0 籼稻 ME0 甲醇 RO0 菜油 TA0 甲酸 商品期货http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLineXm?symbol=CODE例子：http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLine5m?symbol=M05分钟http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLine5m?symbol=M015分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLine15m?symbol=M0 30分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLine30m?symbol=M0 60分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesMiniKLine60m?symbol=M0 日K线 http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesDailyKLine?symbol=M0 http://stock2.finance.sina.com.cn/futures/api/json.php/IndexService.getInnerFuturesDailyKLine?symbol=M1401 股指期货5分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/CffexFuturesService.getCffexFuturesMiniKLine5m?symbol=IF1306 15http://stock2.finance.sina.com.cn/futures/api/json.php/CffexFuturesService.getCffexFuturesMiniKLine15m?symbol=IF1306 30分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/CffexFuturesService.getCffexFuturesMiniKLine30m?symbol=IF1306 60分钟 http://stock2.finance.sina.com.cn/futures/api/json.php/CffexFuturesService.getCffexFuturesMiniKLine60m?symbol=IF1306 日线 http://stock2.finance.sina.com.cn/futures/api/json.php/CffexFuturesService.getCffexFuturesDailyKLine?symbol=IF1306 转自：https://blog.csdn.net/focusjava/article/details/50394021]]></content>
      <tags>
        <tag>黄金，股票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php红包接口思路和步骤]]></title>
    <url>%2F2018%2F05%2F23%2Fphp%E7%BA%A2%E5%8C%85%E6%8E%A5%E5%8F%A3%E6%80%9D%E8%B7%AF%E5%92%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[模拟微信发红包，支持个人，群组普通红包、拼手气红包 快速开始：大概思路： 发红包的时候存好队列 抢红包就读取队列，队列为空即抢完，将抢了的人记起来，再抢就跳领取记录页面 红包设置有过期时间，过期未领取返回发红包人账户 数据库设计：红包发放表，记录所有发的红包 12345678910111213141516171819CREATE TABLE `red_packet` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `user_id` int(10) unsigned NOT NULL DEFAULT 0 COMMENT &apos;用户id&apos;, `user_name` varchar(100) NOT NULL DEFAULT &apos;&apos;, `for_id` varchar(30) NOT NULL COMMENT &apos;发送对象，可以是用户ID，可以是群组ID&apos;, `rp_type` tinyint(2) unsigned NOT NULL DEFAULT 1 COMMENT &apos;红包类型，1、普通，2、二维码红包&apos;, `type` tinyint(1) unsigned NOT NULL DEFAULT 0 COMMENT &apos;类型：1、个人，2、群普通，3、群拼手气&apos;, `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &apos;&apos; COMMENT &apos;备注&apos;, `number` int(10) NOT NULL COMMENT &apos;数量&apos;, `total_money` decimal(10,2) unsigned NOT NULL DEFAULT 0 COMMENT &apos;总金额&apos;, `single_money` decimal(10,2) unsigned NOT NULL DEFAULT 0 COMMENT &apos;单个金额&apos;, `return_money` decimal(10,2) unsigned NOT NULL DEFAULT 0 COMMENT &apos;退还金额&apos;, `expend_time` tinyint unsigned NOT NULL DEFAULT 0 COMMENT &apos;领取完消耗时间&apos;, `status` tinyint(2) NOT NULL DEFAULT 1 COMMENT &apos;1、正常，2、已抢完，3、已过期&apos;, `created_at` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `user_id` (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;红包发放表&apos; 红包领取日志表，查询红包详情和所有红包记录 12345678910111213CREATE TABLE `red_packet_log` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `rp_id` int(10) unsigned NOT NULL DEFAULT 0 COMMENT &apos;红包id&apos;, `user_id` int(10) unsigned NOT NULL DEFAULT 0 COMMENT &apos;领取人id&apos;, `name` varchar(100) NOT NULL DEFAULT &apos;&apos;, `money` decimal(10,2) unsigned NOT NULL DEFAULT 0 COMMENT=&apos;领了多少钱&apos;, `is_good` tinyint(1) unsigned NOT NULL DEFAULT 0 COMMENT &apos;是否手气最佳：0否，1是&apos;, `created_at` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `rp_id` (`rp_id`), KEY `user_id` (`user_id`), KEY `created_at` (`created_at`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;红包领取日志表&apos; 代码实践：发红包在发红包的时候将金额分配好，领取的时候直接拿数据 在Redis队列里面存储 红包ID，发红包人，数量，时间 个人和群普通都好处理，拼手气红包就要用算法进行分配 1234567891011121314151617181920212223242526272829// $number 发多少人， // $total_money 总金额，// $min 最少拿到多少（这里默认设置0.01，在输入的时候做下限制）// $i = 1 最后一个拿剩余金额for ($i = 1; $i &lt; $number; $i++) &#123; $safe_total = ($total_money - ($number - $i) * $min) / ($number - $i);//随机安全上限 $safe_total = $safe_total &lt; $min ? $min : $safe_total; $money = mt_rand($min * 100, $safe_total * 100) / 100; $total_money = bcsub($total_money, $money, 2); //限制到2位小数 //存储到数组 ...&#125;// $total_money为剩余金额，存储到数组...//算出手气最佳，is_good 更新为1...// 剩余金额存储到队列...//将数组打乱shuffle($sorted);//集体存储到队列... 抢红包123456789101112131415161718192021//接收红包ID，并进行判断...//判断是否已经抢过，抢完，失效...//读取队列，红包记录存储，推送消息，资金处理...所有状态const STATUS_NO_SELF = 0; //个人红包不能自己抢const STATUS_SUCCESS = 1; //成功const STATUS_GRAB_OVER = 2; //抢完const STATUS_GRABED = 3; //已领取过const STATUS_ERROR = 4; //程序错误const STATUS_EXPIRED = 5; //红包失效 红包过期检测后台跑个任务检测，过期就将钱返还到发红包人账户，并且记录返还金额，并推送消息 后记：支付宝红包可以做一个判断，加一个类型，其他步骤类似]]></content>
      <tags>
        <tag>红包，并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php调redis常用方法]]></title>
    <url>%2F2018%2F02%2F23%2Fphp%E8%B0%83redis%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*** String * --------------* set key value 设置一个值* get key 获取一个值* del key 删除一个值** List* --------------* lpush key value | rpush key value 插入一个值* lpop key | rpop 弹出一个值* lrange key offset end | lgetrange key offset end 取列表里指定范围的值* lindex key index 获取指定index的单个值** lsize key 获取列表长度* lset key index value 设置指定index的值* ltrim key offset end 截取指定范围内的元素，其余的删除* lrem key value index 删除指定范围的值** Set* --------------* sadd key value 添加元素* smembers key 查看所有元素* srem key value 删除某个元素* sismember key value 是否存在* scard key 查看数量* spop key 随机取出一个返回并删除* sinter key1 key2 返回集合的交集* sinterstore output key1 key2 返回的交集丢到output中* sunion key1 key2 返回集合的并集* sunionstore output key1 key2 返回的并集丢到output中* sdiff key1 key2 返回集合的差集* sdiffstore output key1 key2 返回的差集丢到output中** Sorted Set* --------------* zadd key score value 添加元素* zrange key offset end [true|false] 取列表里指定范围的值，[是否键值反转]* zscore key value 返回score* zcard key 查看数量* zrem key value 删除某个元素* zcount key min max 返回集合中介于min和max之间的值的个数* zrangebyscore key min max 返回有序集合中score介于min和max之间的值* zrevrange key min max 返回集合中指定区间内所有的值* zincrby key number value 指定值的socre增加* zremrangebyscore key min max 移除有序集合中score介于min和max之间的值** Hash* --------------* hset arr key value 设置值，重复设置会覆盖* hget arr key 获取值* hkeys arr 获取hash中所有key* hvals arr 获取hash中所有值，顺序是随机的* hgetall arr 获取key和value，随机顺序* hlen arr 获取key的数量* hdel arr key 删除key*****///多个hash值设置//实例化redis$redis = new Redis();//连接$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);//字典//批量设置多个key的值$arr = [1=&gt;1, 2=&gt;2, 3=&gt;3, 4=&gt;4, 5=&gt;5];$redis-&gt;hmset(&apos;hash&apos;, $arr);print_r($redis-&gt;hgetall(&apos;hash&apos;));echo &apos;&lt;br&gt;&apos;;// 批量获得额多个key的值$arr = [1, 2, 3, 5];$hash = $redis-&gt;hmget(&apos;hash&apos;, $arr);print_r($hash);echo &apos;&lt;br&gt;&apos;;//检测hash中某个key知否存在echo $redis-&gt;hexists(&apos;hash&apos;, &apos;1&apos;);echo &apos;&lt;br&gt;&apos;;var_dump($redis-&gt;hexists(&apos;hash&apos;, &apos;cat&apos;));echo &apos;&lt;br&gt;&apos;;print_r($redis-&gt;hgetall(&apos;hash&apos;));echo &apos;&lt;br&gt;&apos;;//给hash表中key增加一个整数值$redis-&gt;hincrby(&apos;hash&apos;, &apos;1&apos;, 1);print_r($redis-&gt;hgetall(&apos;hash&apos;));echo &apos;&lt;br&gt;&apos;;//给hash中的某个key增加一个浮点值$redis-&gt;hincrbyfloat(&apos;hash&apos;, 2, 1.3);print_r($redis-&gt;hgetall(&apos;hash&apos;));echo &apos;&lt;br&gt;&apos;;//结果// Array ( [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 )// Array ( [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [5] =&gt; 5 )// 1// bool(false)// Array ( [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 )// Array ( [1] =&gt; 2 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 )// Array ( [1] =&gt; 2 [2] =&gt; 3.3 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 )]]></content>
      <tags>
        <tag>redis, php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无限级分类系列方法]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[无限级分类系列方法根据PID（父级ID）查询所有下级12345678910111213141516function getTree($array, $pid =0, $level = 0, &amp;$list = [])&#123; foreach ($array as $key =&gt; $value)&#123; //第一次遍历,找到父节点为根节点的节点 也就是pid=0的节点 if ($value[&apos;pid&apos;] == $pid)&#123; //父节点为根节点的节点,级别为0，也就是第一级 $value[&apos;level&apos;] = $level; //把数组放到list中 $list[] = $value; //把这个节点从数组中移除,减少后续递归消耗 unset($array[$key]); //开始递归,查找父ID为该节点ID的节点,级别则为原级别+1 $this-&gt;getTree($array, $value[&apos;id&apos;], $level+1, $list); &#125; &#125; return $list;&#125; 列表转树形123456789101112131415161718function list2Tree($items,$id=&apos;id&apos;,$pid=&apos;pid&apos;,$son = &apos;children&apos;)&#123; $tree = array(); //格式化的树 $tmpMap = array(); //临时扁平数据 foreach ($items as $item) &#123; $tmpMap[$item[$id]] = $item; &#125; foreach ($items as $item) &#123; if (isset($tmpMap[$item[$pid]])) &#123; $tmpMap[$item[$pid]][$son][] = &amp;$tmpMap[$item[$id]]; &#125; else &#123; $tree[] = &amp;$tmpMap[$item[$id]]; &#125; &#125; unset($tmpMap); return $tree;&#125; 对查询结果集进行排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 对查询结果集进行排序 * @access public * @param array $list 查询结果 * @param string $field 排序的字段名 * @param array $sortby 排序类型 * asc正向排序 desc逆向排序 nat自然排序 * @return array | bool */function list_sort_by($list,$field, $sortby=&apos;asc&apos;) &#123; if(is_array($list))&#123; $refer = $resultSet = array(); foreach ($list as $i =&gt; $data) $refer[$i] = &amp;$data[$field]; switch ($sortby) &#123; case &apos;asc&apos;: // 正向排序 asort($refer); break; case &apos;desc&apos;:// 逆向排序 arsort($refer); break; case &apos;nat&apos;: // 自然排序 natcasesort($refer); break; &#125; foreach ( $refer as $key=&gt; $val)&#123; if(isset($list[$key][&apos;children&apos;]))&#123; $refer1 = $children = []; foreach ($list[$key][&apos;children&apos;] as $j =&gt; $data) $refer1[$j] = &amp;$data[$field]; switch ($sortby) &#123; case &apos;asc&apos;: // 正向排序 asort($refer1); break; case &apos;desc&apos;:// 逆向排序 arsort($refer1); break; case &apos;nat&apos;: // 自然排序 natcasesort($refer1); break; &#125; foreach ( $refer1 as $k =&gt; $v) $children[] = $list[$key][&apos;children&apos;][$k]; $list[$key][&apos;children&apos;] = $children; &#125; $resultSet[] = &amp;$list[$key]; &#125; return $resultSet; &#125; return false;&#125;]]></content>
      <tags>
        <tag>无限级，分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel JWT 认证系统]]></title>
    <url>%2F2017%2F10%2F27%2Flaravel-JWT-%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[API认证基于laravel的扩展包tymon/jwt-auth 更多使用方法可查询 官方文档 Laravel安装使用 composer 安装1composer require tymon/jwt-auth 1.0.0-rc.2 添加服务提供商（Laravel 5.4或更低版本）将服务提供程序添加到配置文件中的providers数组，config/app.php如下所示：123456'providers' =&gt; [ ... Tymon\JWTAuth\Providers\LaravelServiceProvider::class,] 发布配置运行以下命令以发布程序包配置文件 1php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider" 您现在应该有一个config/jwt.php文件，允许您配置此程序包的基础知识。 生成密钥我已经包含了一个帮助器命令来为您生成一个键：1php artisan jwt:secret 这将.env使用类似的内容更新您的文件JWT_SECRET=foobar 它是用于签署令牌的密钥。具体如何发生取决于您选择使用的算法。 快速开始更新您的用户模型首先，您需要Tymon\JWTAuth\Contracts\JWTSubject在User模型上实现合同，这需要您实现2个方法getJWTIdentifier()和getJWTCustomClaims()。 下面的例子可以让你了解它的外观。显然，您应该根据自己的需要进行必要的更改。 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App;use Tymon\JWTAuth\Contracts\JWTSubject;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;class User extends Authenticatable implements JWTSubject&#123; use Notifiable; // Rest omitted for brevity /** * Get the identifier that will be stored in the subject claim of the JWT. * * @return mixed */ public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; /** * Return a key value array, containing any custom claims to be added to the JWT. * * @return array */ public function getJWTCustomClaims() &#123; return []; &#125;&#125; 创建中间件为token认证创建一个中间件1php artisan make:middleware JwtToken 【 客户端监控401为错误token或token过期，403为重新获取token 】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace App\Http\Middleware;use Auth;use Closure;use Illuminate\Support\Facades\Log;use InvalidArgumentException;use Tymon\JWTAuth\Exceptions\JWTException;use Tymon\JWTAuth\Exceptions\TokenInvalidException;use Tymon\JWTAuth\Http\Middleware\BaseMiddleware;use Tymon\JWTAuth\Exceptions\TokenExpiredException;use Symfony\Component\HttpKernel\Exception\UnauthorizedHttpException;// 注意，我们要继承的是 jwt 的 BaseMiddlewareclass JwtToken extends BaseMiddleware&#123; /** * @param $request * @param Closure $next * @return \Illuminate\Http\JsonResponse|mixed * @throws JWTException 在header上返回新token，并缓存一分钟，避免碰到并发问题 */ public function handle($request, Closure $next) &#123; // 检查此次请求中是否带有 token，如果没有则抛出异常。 if (! $token = $this-&gt;auth-&gt;setRequest($request)-&gt;getToken()) &#123; return response()-&gt;json([&apos;error&apos;=&gt;&apos;token_not_provided1&apos;], 401); &#125; // 使用 try 包裹，以捕捉 token 过期所抛出的 TokenExpiredException 异常 try &#123; // 检测用户的登录状态，如果正常则通过 if ($this-&gt;auth-&gt;parseToken()-&gt;authenticate()) &#123; return $next($request); &#125; return response()-&gt;json([&apos;error&apos;=&gt;&apos;token_not_provided21&apos;], 401); &#125; catch (TokenExpiredException $exception) &#123; // 此处捕获到了 token 过期所抛出的 TokenExpiredException 异常，我们在这里需要做的是刷新该用户的 token 并将它添加到响应头中 try &#123; // 刷新用户的 token $token = $this-&gt;auth-&gt;refresh(); $request-&gt;headers-&gt;set(&apos;Authorization&apos;,&apos;Bearer &apos;.$token); //保证处理同时请求的问题 Cache::put(&apos;token_flush&apos;.$expired_token, $token, 1); &#125; catch (JWTException $exception) &#123; //过期token延长一分钟时间使用 if(Cache::get(&apos;token_flush&apos;.$expired_token))&#123; $token = Cache::get(&apos;token_flush&apos;.$expired_token); $request-&gt;headers-&gt;set(&apos;Authorization&apos;,&apos;Bearer &apos;.$token); &#125;else&#123; return response()-&gt;json([&apos;error&apos;=&gt;&apos;invalid token2&apos;], 401); &#125; &#125; &#125;catch (TokenInvalidException $exception)&#123; //token无效返回 return response()-&gt;json([&apos;error&apos;=&gt;&apos;invalid token1&apos;], 401); &#125; //在response header里面返回token $response = $next($request); //这里名字自己定 $response-&gt;header(&apos;Authorization123&apos;, $token); return $response; &#125;&#125; 拦截异常在app/Exceptions/Handler.php 12345678public function render($request, Exception $exception) &#123; if ($exception instanceof JWTException) &#123; return response()-&gt;json([&apos;error&apos;=&gt;&apos;invalid token213&apos;], 401); &#125; return parent::render($request, $exception); &#125; 注册中间件1234protected $routeMiddleware = [ ... &apos;jwt.token&apos; =&gt; \App\Http\Middleware\CheckToken::class,]; 添加一些基本认证路由首先让我们添加一些路由routes/api.php如下：12345678Route::post(&apos;login&apos;, &apos;AuthController@login&apos;);Route::group([&apos;middleware&apos; =&gt; &apos;jwt.token&apos;], function () &#123; Route::post(&apos;logout&apos;, &apos;AuthController@logout&apos;); Route::post(&apos;me&apos;, &apos;AuthController@me&apos;);&#125;); 创建AuthController然后AuthController手动或通过运行artisan命令创建：1php artisan make:controller AuthController 然后添加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpnamespace App\Http\Controllers;use Illuminate\Support\Facades\Auth;use App\Http\Controllers\Controller;class AuthController extends Controller&#123; /** * Create a new AuthController instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware(&apos;auth:api&apos;, [&apos;except&apos; =&gt; [&apos;login&apos;]]); &#125; /** * Get a JWT via given credentials. * * @return \Illuminate\Http\JsonResponse */ public function login() &#123; $credentials = request([&apos;email&apos;, &apos;password&apos;]); if (! $token = auth()-&gt;guard(&apos;api&apos;)-&gt;attempt($credentials)) &#123; return response()-&gt;json([&apos;error&apos; =&gt; &apos;Unauthorized&apos;], 401); &#125; return $this-&gt;respondWithToken($token); &#125; /** * Get the authenticated User. * * @return \Illuminate\Http\JsonResponse */ public function me() &#123; return response()-&gt;json(auth()-&gt;user()); &#125; /** * Log the user out (Invalidate the token). * * @return \Illuminate\Http\JsonResponse */ public function logout() &#123; auth()-&gt;logout(); return response()-&gt;json([&apos;message&apos; =&gt; &apos;Successfully logged out&apos;]); &#125; /** * Get the token array structure. * * @param string $token * * @return \Illuminate\Http\JsonResponse */ protected function respondWithToken($token) &#123; return response()-&gt;json([ &apos;access_token&apos; =&gt; $token, &apos;token_type&apos; =&gt; &apos;bearer&apos;, &apos;expires_in&apos; =&gt; env(&apos;JWT_TTL&apos;, 60) * 60 ]); &#125;&#125; 您现在应该能够http://example.dev/api/login使用一些有效的凭据POST到登录端点（例如），并看到如下响应：12345&#123; &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 3600&#125; 然后，此令牌可用于向您的应用程序发出经过身份验证的请求。 经过身份验证的请求有很多方法，可以通过http发送令牌： 授权标头 Authorization: Bearer eyJhbGciOiJIUzI1NiI… 查询字符串参数 http://example.dev/api/me?token=eyJhbGciOiJIUzI1NiI... 结束需要注意的是，这里将token刷新在中间件里做了自动刷新 在token过期的时候会返回新的token和请求数据 返回401为无效token或refresh_ttl token过期 更多使用方法可查询 官方文档]]></content>
      <tags>
        <tag>Laravel, API, jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Hexo在本地搭建一个博客]]></title>
    <url>%2F2017%2F10%2F23%2FHexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[阿里云上面的服务器到期了，不想再续了，所有用Github搭了一个博客，大家可以做一下参考 快速开始安装Hexo1$ npm install -g hexo-cli 请先安装 nodejs 和 git 使用1234$ hexo i blog //init的缩写 blog是项目名$ cd blog //切换到站点根目录$ hexo g //generetor的缩写$ hexo s //server的缩写 打开浏览器输入http://localhost:4000查看，可以访问表示安装成功 选择主题123$ git clone https://github.com/iissnan/hexo-theme-next themes/next$ vim _config.yml$ theme: next 找到配置 theme， 修改为 theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 123$ hexo clean //清除缓存$ hexo g //重新生成代码$ hexo s //部署到本地 打开浏览器输入http://localhost:4000查看效果 配置主题1$ vim /themes/next/_congig.yml 可选择下面任意主题12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 查看效果123$ hexo clean //清除缓存$ hexo g //重新生成代码$ hexo s //部署到本地 部署新建版本库名字： yourname.github.io（固定） 修改配置：1$ vim _config.yml 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 替换其中的yourname为你的Github账号 注意！！！冒号的后面一定一定一定要有一个空格！！ 最后： 12$ npm install hexo-deployer-git --save$ hexo d // 部署的命令]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo, github, blog</tag>
      </tags>
  </entry>
</search>
